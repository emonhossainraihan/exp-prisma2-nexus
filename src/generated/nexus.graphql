### This file was generated by Nexus Schema
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type Mutation {
  createOneProduct(data: ProductCreateInput!): Product!
  createOneVariant(data: VariantCreateInput!): Variant!
  deleteManyProduct(where: ProductWhereInput): BatchPayload!
  deleteManyVariant(where: VariantWhereInput): BatchPayload!
  deleteOneProduct(where: ProductWhereUniqueInput!): Product
  deleteOneVariant(where: VariantWhereUniqueInput!): Variant
  updateManyProduct(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  updateManyVariant(data: VariantUpdateManyMutationInput!, where: VariantWhereInput): BatchPayload!
  updateOneProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateOneVariant(data: VariantUpdateInput!, where: VariantWhereUniqueInput!): Variant
  upsertOneProduct(create: ProductCreateInput!, update: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product!
  upsertOneVariant(create: VariantCreateInput!, update: VariantUpdateInput!, where: VariantWhereUniqueInput!): Variant!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Product {
  createdAt: DateTime!
  id: Int!
  name: String!
  updatedAt: DateTime!
  variants(after: VariantWhereUniqueInput, before: VariantWhereUniqueInput, first: Int, last: Int): [Variant!]!
}

input ProductCreateInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
  variants: VariantCreateManyWithoutProductInput
}

input ProductCreateOneWithoutVariantsInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutVariantInput
  create: ProductCreateWithoutVariantsInput
}

input ProductCreateOrConnectWithoutVariantInput {
  create: ProductCreateWithoutVariantsInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateWithoutVariantsInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
}

input ProductUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  variants: VariantUpdateManyWithoutProductInput
}

input ProductUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProductUpdateOneRequiredWithoutVariantsInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutVariantInput
  create: ProductCreateWithoutVariantsInput
  update: ProductUpdateWithoutVariantsDataInput
  upsert: ProductUpsertWithoutVariantsInput
}

input ProductUpdateWithoutVariantsDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProductUpsertWithoutVariantsInput {
  create: ProductCreateWithoutVariantsInput!
  update: ProductUpdateWithoutVariantsDataInput!
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  updatedAt: DateTimeFilter
  variants: VariantListRelationFilter
}

input ProductWhereUniqueInput {
  id: Int
}

type Query {
  product(where: ProductWhereUniqueInput!): Product
  products(after: ProductWhereUniqueInput, before: ProductWhereUniqueInput, first: Int, last: Int): [Product!]!
  variant(where: VariantWhereUniqueInput!): Variant
  variants(after: VariantWhereUniqueInput, before: VariantWhereUniqueInput, first: Int, last: Int): [Variant!]!
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Variant {
  createdAt: DateTime!
  id: Int!
  name: String!
  prodId: Int!
  product: Product!
  updatedAt: DateTime!
}

input VariantCreateInput {
  createdAt: DateTime
  name: String!
  product: ProductCreateOneWithoutVariantsInput!
  updatedAt: DateTime
}

input VariantCreateManyWithoutProductInput {
  connect: [VariantWhereUniqueInput!]
  connectOrCreate: [VariantCreateOrConnectWithoutProductInput!]
  create: [VariantCreateWithoutProductInput!]
}

input VariantCreateOrConnectWithoutProductInput {
  create: VariantCreateWithoutProductInput!
  where: VariantWhereUniqueInput!
}

input VariantCreateWithoutProductInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
}

input VariantListRelationFilter {
  every: VariantWhereInput
  none: VariantWhereInput
  some: VariantWhereInput
}

input VariantScalarWhereInput {
  AND: [VariantScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  NOT: [VariantScalarWhereInput!]
  OR: [VariantScalarWhereInput!]
  prodId: IntFilter
  updatedAt: DateTimeFilter
}

input VariantUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  product: ProductUpdateOneRequiredWithoutVariantsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input VariantUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input VariantUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input VariantUpdateManyWithoutProductInput {
  connect: [VariantWhereUniqueInput!]
  connectOrCreate: [VariantCreateOrConnectWithoutProductInput!]
  create: [VariantCreateWithoutProductInput!]
  delete: [VariantWhereUniqueInput!]
  deleteMany: [VariantScalarWhereInput!]
  disconnect: [VariantWhereUniqueInput!]
  set: [VariantWhereUniqueInput!]
  update: [VariantUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [VariantUpdateManyWithWhereNestedInput!]
  upsert: [VariantUpsertWithWhereUniqueWithoutProductInput!]
}

input VariantUpdateManyWithWhereNestedInput {
  data: VariantUpdateManyDataInput!
  where: VariantScalarWhereInput!
}

input VariantUpdateWithoutProductDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input VariantUpdateWithWhereUniqueWithoutProductInput {
  data: VariantUpdateWithoutProductDataInput!
  where: VariantWhereUniqueInput!
}

input VariantUpsertWithWhereUniqueWithoutProductInput {
  create: VariantCreateWithoutProductInput!
  update: VariantUpdateWithoutProductDataInput!
  where: VariantWhereUniqueInput!
}

input VariantWhereInput {
  AND: [VariantWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  NOT: [VariantWhereInput!]
  OR: [VariantWhereInput!]
  prodId: IntFilter
  product: ProductWhereInput
  updatedAt: DateTimeFilter
}

input VariantWhereUniqueInput {
  id: Int
}
